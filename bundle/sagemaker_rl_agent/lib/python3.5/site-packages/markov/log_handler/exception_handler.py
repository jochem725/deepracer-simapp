# Handles logging and graceful exit
import json
import logging
import os
import datetime
import inspect
from collections import OrderedDict
import traceback
import re
from markov.log_handler.constants import (SIMAPP_ERROR_HANDLER_EXCEPTION, SIMAPP_EVENT_SYSTEM_ERROR,
                                          SIMAPP_EVENT_USER_ERROR, SIMAPP_EVENT_ERROR_CODE_400,
                                          SIMAPP_ERROR_EXIT, FAULT_MAP, FAULT_MAP_UNCLASSIFIED)
from markov.constants import SIMAPP_VERSION
from markov.log_handler.logger import Logger

logger = Logger(__name__, logging.INFO).get_logger()

def log_and_exit(msg, error_source, error_code):
    '''Helper method that logs an exception and exits the application

    Args:
        msg (String): The message to be logged
        error_source (String): The source of the error, training worker, rolloutworker, etc
        error_code (String): 4xx or 5xx error

    Returns:
        JSON string data format: Consists of the error log dumped
    '''
    try:
        dict_obj = OrderedDict()
        json_format_log = dict()
        fault_code = get_fault_code_for_error(msg)
        dict_obj['version'] = SIMAPP_VERSION
        dict_obj['date'] = str(datetime.datetime.now())
        dict_obj['function'] = inspect.stack()[2][3]
        dict_obj['message'] = msg
        dict_obj["exceptionType"] = error_source
        if error_code == SIMAPP_EVENT_ERROR_CODE_400:
            dict_obj["eventType"] = SIMAPP_EVENT_USER_ERROR
        else:
            dict_obj["eventType"] = SIMAPP_EVENT_SYSTEM_ERROR
        dict_obj["errorCode"] = error_code
        #TODO: Include fault_code in the json schema to track faults - pending cloud team assistance
        #dict_obj["faultCode"] = fault_code
        json_format_log["simapp_exception"] = dict_obj
        logger.error(json.dumps(json_format_log))
        # Temporary fault code log
        logger.error("ERROR: FAULT_CODE: {}".format(fault_code))
        simapp_exit_gracefully()

    except Exception:
        log_and_exit("Exception thrown in logger - log_and_exit",
                     SIMAPP_ERROR_HANDLER_EXCEPTION,
                     SIMAPP_EVENT_ERROR_CODE_400)

def simapp_exit_gracefully(simapp_exit=SIMAPP_ERROR_EXIT):
    #simapp exception leading to exiting the system
    # -close the running processes
    # -upload simtrace data to S3
    logger.info("simapp_exit_gracefully: simapp_exit-{}".format(simapp_exit))
    logger.info("Terminating simapp simulation...")
    stack_trace = traceback.format_exc()
    logger.info("deepracer_racetrack_env - callstack={}".format(stack_trace))
    if simapp_exit == SIMAPP_ERROR_EXIT:
        os._exit(1)

def get_fault_code_for_error(msg):
    '''Helper method that classifies an error message generated in log_and_exit 
    into individual error codes from the maintained FAULT_MAP. If an unseen error
    is seen, it is classified into fault code 0

    Args:
        msg (String): The message to be classified

    Returns:
        String: Consists of classified fault code
    '''
    for fault_code, err in FAULT_MAP.items():
        # Match errors stored in FAULT_MAP with the exception thrown
        classified = re.search(r"{}".format(err.lower()), msg.lower()) is not None
        if classified:
            return str(fault_code)
    return FAULT_MAP_UNCLASSIFIED
